<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>前端总结-知识点-答案</title>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black" />
<meta name="format-detection"content="telephone=no, email=no" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black" />
<meta name="format-detection" content="telphone=no, email=no" />
<meta name="renderer" content="webkit">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="HandheldFriendly" content="true">
<meta name="MobileOptimized" content="320">
<meta name="screen-orientation" content="portrait">
<meta name="x5-orientation" content="portrait">
<meta name="full-screen" content="yes">
<meta name="x5-fullscreen" content="true">
<meta name="browsermode" content="application">
<meta name="x5-page-mode" content="app">
<meta name="msapplication-tap-highlight" content="no">
<style type="text/css">
    *{margin:0; padding:0; font-size:14px; color:#333; font-family: "微软雅黑"}
    h1{ line-height:100px; text-align:center; font-size: 30px; border-bottom: 4px solid #c6c6c6;}
    .answer{ display: none }
    .list{ line-height:25px; padding: 10px 0 10px 5%; border-bottom: 1px solid #d2d2d2; position:relative; min-height: 25px}
    .answer .list:last-child{ border-bottom:none; }
    .list .num{ position:absolute; cursor: pointer}
    .list .ct{ margin-left: 30px;}
    .list h2{ padding-bottom:10px;}
    .red{ color:#f00; }
    .title{ line-height:60px; padding-left: 5%; border-top: 1px solid #d2d2d2;}
    .title a{ font-size: 18px; color: #f00; font-weight: 700; text-decoration:none}
</style>
<script class="jquery library" src="styles/jquery-1.8.3.min.js" type="text/javascript"></script>
<script type="text/javascript" src="styles/brush.js"></script>
<link type="text/css" rel="stylesheet" href="styles/shCore.css"/>
<link type="text/css" rel="stylesheet" href="styles/shThemeDefault.css"/>
</head>
<body>
<h1>附记录</h1>

<!-- css -->
<div class="title"><a href="answer.html" target="_blank">css</a></div>
<div class="answer">
    <div class="list">
        <span class="num" title="点击折叠">1、</span>
        <div class="ct">
            <h2>列举所有css属性</h2>
            <pre class='brush: css'>
                position、visibility、overflow、clip、display、margin、padding
                width、height、border、background、font-size、line-height、color
            </pre>
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">2、</span>
        <div class="ct">
            <h2>自适应布局，响应式布局怎么实现，他们的区别是。</h2>
            自适应布局：是指显示在不同大小终端设备上的技术。<br>
            响应式布局：为不同终端的用户提供更加舒适的界面和更好的用户体验。<br><br>
            主要使用CSS3的media query来适应
            <pre class="brush:css">
                @media screen and ( max-width:640px ){
                    div{ line-height:55px; }
                }
            </pre>
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">3、</span>
        <div class="ct">
            <h2>css单位rem、em、px有和区别</h2>
            px：相对长度单位，像素px是相对于显示器屏幕分辨率而言的。<br>
            em：相对长度单位，相对于当前对象内文本的字体尺寸。当前行内文本未设置字体尺寸，则相对于浏览器的默认字体尺寸。<br>
            rem：相对长度单位，但相对的只是html根元素（ie8以前不支持，兼容处理）。
            <pre class="brush:css">
                .box {
                  font-size:14px;
                  font-size:0.875em;
               }
            </pre>
            <br>

            <b>em计算方式：</b>浏览器的默认字体高都是16px，1em = 16px。那么12px = 0.75em、10px = 0.625em。<br>
            为了简化font-size的换算，需要在css中的body选择器中声明font-size = 62.5%，
            这就使em值变为 16px * 62.5% = 10px，这样12px = 1.2em、10px = 1em <br>
            也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">4、</span>
        <div class="ct">
            <h2>box-flex是什么<b class="red">（重要）</b></h2>
            弹性布局<br>
            box-orient：用来确定子元素的方向，是横着排还是竖着，horizontal、vertical...<br>
            box-direction：可以调整顺序，normal、reverse、inherit<br>
            <pre class='brush: html'>
                <div class="boxFlex">
                    <div class="list two">1</div>
                    <div class="list one">2</div>
                    <div class="list one">3</div>
                </div>
            </pre>
            <pre class='brush: css'>
                .boxFlex {
                    display: -moz-box; display: -webkit-box; display: box;
                    width: 800px; margin: 40px auto; padding: 20px; background: #f0f3f9;
                 }
                .list { padding: 0 1em; line-height:50px; }
                .one { -moz-box-flex: 1; -webkit-box-flex: 1; box-flex: 1; }
                .one{ -moz-box-flex: 2; -webkit-box-flex: 2; box-flex: 2; }
            </pre>
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">5、</span>
        <div class="ct">
            <h2>css hack有哪些</h2>
            <pre class="brush: css">
                _           ：ie6
                *           ：ie6、ie7
                *+          ：ie7
                +           ：ie6、ie7
                \9          ：ie6、ie7、ie8、ie9、ie10
                \0          ：ie8、ie9、ie10
                \9\0        ：ie9、ie10
                !important  ：除ie6外
                -moz-       ：Firefox
                -webkit-    ：Safari
                -o-         ：Opera
                -ms-        ：Ie
            </pre>
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">6、</span>
        <div class="ct">
            <h2>css优先级怎么计算</h2>
            原则一： 继承不如指定<br>
            原则二： #id > .class > 标签选择符<br>
            原则三：越具体越强大<br>
            原则四：标签#id >#id ; 标签.class > .class<br><br>

            <span class="red">注意：</span><br>
            1、!important声明的样式优先级最高，如果冲突再进行计算。<br>
            2、如果优先级相同，则选择最后出现的样式。<br>
            3、继承得到的样式的优先级最低。<br>
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">7、</span>
        <div class="ct">
            <h2>css3新增伪类</h2>
            :first-child选择某个元素的第一个子元素。<br>
            :last-child选择某个元素的最后一个子元素。<br>
            :nth-child()选择某个元素的一个或多个特定的子元素。<br>
            :nth-last-child()选择某个元素的一个或多个特定的子元素，从这个元素的最后一个子元素开始算。<br>
            :nth-of-type()选择指定的元素。<br>
            :nth-last-of-type()选择指定的元素，从元素的最后一个开始计算。<br>
            :first-of-type选择一个上级元素下的第一个同类子元素。<br>
            :last-of-type选择一个上级元素的最后一个同类子元素。<br>
            :only-child选择的元素是它的父元素的唯一一个了元素。<br>
            :only-of-type选择一个元素是它的上级元素的唯一一个相同类型的子元素。<br>
            :empty选择的元素里面没有任何内容。<br>
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">8、</span>
        <div class="ct">
            <h2>抽离样式模块怎么写,说出思路</h2>
            格斯其职，能公用就公用。<br>
            1、提取公共样式。<br>
            2、提取各个模板的可能公用的样式。<br>
            3、模块本身的个性化样式。<br>
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">9、</span>
        <div class="ct">
            <h2>怎么让chrome支持小于12px的文字</h2>
            <pre class="brush:css">
                html{ -webkit-text-size-adjust:none; } //新版chrome已经不支持
            </pre>
            目前解决方案：transform:scale()，需要块级元素
            <pre class="brush:css">
                div{
                    -webkit-transform:scale(0.8);
                    -o-transform:scale(1);
                    display:inline-block;
                }
            </pre>
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">10、</span>
        <div class="ct">
            <h2>png、jpg、gif这些图片格式解释一下</h2>
            png：支持透明，PNG8最多储存256个索引色，PNG24可以储存1600多万个。<br>
            jpg：质量比较好，色彩比较丰满，做小图标可以选择PNG。<br>
            gif：动画，失真大。<br>
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">11、</span>
        <div class="ct">
            <h2>retina屏怎么解决1px问题</h2>
            <pre class="brush:css">
                <div class="line">1px</div>
                <div class="scale">0.5px</div>

                .line {
                    height: 50px; line-height: 50px;
                    background-color: #CCC; border-bottom:1px solid red
                }
                .scale {
                    position: relative; height: 50px; line-height: 50px; background-color: #CCC
                }
                .scale:after {
                    position: absolute; content: ''; width: 100%; left: 0;
                    bottom: 0; height: 1px; background-color: red;
                    -webkit-transform: scale(1,.5); transform: scale(1,.5);
                    -webkit-transform-origin: center bottom; transform-origin: center bottom
                }
            </pre>
        </div>
    </div>
</div>

<!-- JavaScript基础知识 -->
<div class="title"><a href="answer.html" target="_blank">JavaScript基础知识</a></div>
<div class="answer">
    <div class="list">
        <span class="num" title="点击折叠">1、</span>
        <div class="ct">
            <h2>dom基本操作</h2>
            document.querySelector //查询元素 <br>
            document.createElement //创建dom <br>
            document.createDocumentFragment //创建碎片，大数据下改善性能<br>
            setAttribute //设置属性<br>
            innerHTML //添加内容<br>
            appendChild //插入dom<br>
            document.body.removeChild //删除dom<br>
            <pre class='brush: javascript'>
                var body = document.querySelector( "body" );
                var doc = document.createDocumentFragment();
                var createDiv = document.createElement( "div" );
                var text = document.createTextNode( "新元素" );
                createDiv.appendChild( text );
                createDiv.setAttribute( "state", "ok" );
                doc.appendChild( createDiv );
                body.appendChild( doc );
                body.removeChild( dom节点 );
            </pre>
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">2、</span>
        <div class="ct">
            <h2>怎么监听input值是否变化</h2>
            这里需要用到onchange，onpropertychange。<br>
            onchange：失去焦点触发，用js直接改变属性，并不能触发此事件。<br>
            onpropertychange：只有ie支持，disable = true的时候失效，只要属性改变都可以触发，ie自定义事件也是用此机制。<br>
            oninput：ie9以下版本不支持，主浏览器支持，但用js直接改变属性，不能触发。<br>
            <pre class="brush:html">
                <input type="text" name="user" value="hello" />
            </pre>
            <pre class='brush: javascript'>
                var input = document.querySelector( "input" );
                input.addEventListener( "input", function( e ) {
                    console.log( this.value );
                });
                input.attachEvent( 'onpropertychange', function( e ) {
                    //用event.propertyName 来检测
                    if ( event.propertyName.toLowerCase() === "value" ) {
                        console.log( this.value );
                    }
                });
            </pre>
            <span class="red">注意：</span><br>
            oninput和onpropertychange这两个事件在ie9中通过右键菜单菜单中的剪切和删除命令删除内容的时候不会触发
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">3、</span>
        <div class="ct">
            <h2>JavaScript数据类型,内存存储区域</h2>
            基本数据类型：Number、String、Boolean、Undefined、Null。<BR>
            复杂数据类型：Object。<br>

            JavaScript变量类型分为原始类型（存放于栈中）、引用类型（存放于堆）。<BR>
            栈：只有一个出口，遵循后进先出（就像一个筒子，往里面放硬币，最后放的硬币是你最先可以拿到的）。<BR>
            堆：用于动态分配的对象，未能确定其大小的数据，存储在栈中的是一个指针，指向他的堆（就像你是你爹的儿子，存在一种关系）。<BR><BR>

            <span class="red">注意：</span><br>
            由此可见：栈效率高于堆，栈只能存储固定的数据。<br><br>

            <span class="red">问题来了：String类型了？</span><br>
            string类型存储在栈中，毋庸置疑，因为没法改变一个值的内容（它是只读的，看似修改，其实是创建一个新的string对象）<br>
            <pre class="brush:javascript">
                var str = "a";
                var str1 = str; //未分配内存，str地址赋给str1
                console.log( str1 ); // a;
                str = "b";  //检测内存不存在，重新分配
                console.log( str1 ); // a;
            </pre>
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">4、</span>
        <div class="ct">
            <h2>如果检测是否数组,对象</h2>
            typeof、instanceof、constructor、toString、Object.prototype.toString、内置方法检测等方式<br>

            <pre class="brush:javascript">
                var toType = Object.prototype.toString;
                typeof [];                                  // object
                typeof {};                                  // object
                [] instanceof Array;                        // true
                [].constructor === Array;                   // true
                toString.call([]) === "[object Array]";     // true
                toType.call([]) === "[object Array]";       // true
                [].push                                     // function push
            </pre>
            <span class="red">注意：</span><br>
            typeof：不能检测引用类型<br>
            constructor：指向可变<br>
            toString.call( arguments ) //[object Object]<br>
            toType.call( arguments ) //[object Arguments]<br>

        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">5、</span>
        <div class="ct">
            <h2>浏览器数据存储有哪些方式</h2>
            1、cookie，每次HTTP请求头信息一起发送，有大小限制（4k）<br>
            2、localStorage，本地存储，不兼容ie8（ie8 json格式）下，大小5M<br>
            3、session，页面关闭失效<br>
            4、userData，ie下有效，可以废了<br>
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">6、</span>
        <div class="ct">
            <h2>cookie怎么操作</h2>
            <pre class="brush:javascript">
                // 存入cookie
                var name = "setcookie";
                var value = "front";
                document.cookie = ( name + "=" + value );

                // 获取cookie
                if ( document.cookie.length > 0 ) {
                    document.cookie;
                }
            </pre>
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">7、</span>
        <div class="ct">
            <h2>严格模式有什么特点</h2>
            消除语法不合理、不严谨、不安全之处，提高编译效率。<BR>

            1、变量必须显式声明。
            <pre class="brush:javascript">
                "use strict";
                v = 1;      //报错 v未声明
            </pre>

            2、某些情况下只允许静态绑定，就是方法属于哪个对象，在编译阶段就确定好，有利于效率提高。<BR>
            作用域分两种：全局作用域，函数作用域。但严格模式下有eval作用域。<BR>
            严格模式中函数作用域下eval用显式声明不在有全局作用域，它只属于自己，只能内部使用。
            <pre class="brush:javascript">
                "use strict";
                var a = 1;
                console.log( eval( "var a = 2; a " ) );     //2
                console.log( a );                           //2
            </pre>
            <pre class="brush:javascript">
                // chrome测试
                ;(function(){
                    "use strict";
                    var a = 1;
                    console.log( eval( "var a = 2; a " ) );     //2
                    console.log( a );                           //1
                })();
            </pre>

            3、this禁止指向全局对象。
            <pre class="brush:javascript">
                ;(function(){
                    "use strict";
                    console.log( this ); //undefined
                })();
            </pre>

            4、禁止调用栈fn.caller。<BR>
            5、禁止删除变量，开启configurable:true可删。
            <pre class="brush:javascript">
                var obj = Object.create( null, { 'val': {
                    value: 1,
                    configurable: true
                }});
                delete obj.val;
            </pre>
            6、禁止使用arguments.callee。<BR>
            7、保留字 implements、interface、let、package、private、protected、public、static、yield。
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">8、</span>
        <div class="ct">
            <h2>null,undefined区别</h2>
            null表示没有对象。<BR>
            undefined表示缺少值，就是还没定义（跟内部执行情况有关）。<BR><BR>
            <span class="red">注意：</span><br>
            null转换数值为0，undefined转换数值为NaN。
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">9、</span>
        <div class="ct">
            <h2>eval是啥</h2>
            “eval()是魔鬼”。<BR>
            可以将字符串生成语句执行<BR>
            eval()也带来了安全隐患，因为被执行的代码（例如从网络来）可能已被篡改。<BR><BR>
            同理：setInterval()、setTimeout()、Function()构造函数传递字符串，大部分情况下，与使用eval()是类似的，因此要避免。<br><br>

            <span class="red">注意：</span><br>
            eval可以干扰作用域。<br>
            Function不管在哪里执行，只看到全局作用域，可以避免本地变量污染。
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">10、</span>
        <div class="ct">
            <h2>函数劫持是什么</h2>
            通过替换JavaScript函数的实现来达到劫持这个函数调用的目的。<BR><BR>
            原理：先保存原函数实现，然后替换为我们自己的函数实现，添加我们自己的处理逻辑后最终再调用原来的函数实现。
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">11、</span>
        <div class="ct">
            <h2>setTimeout,setInterval</h2>
            setInterval以指定周期调用函数。<BR>
            setTimeout指定延迟后调用函数。<BR>
            这两个是在你设定的一个时间点插入到JavaScript引擎维护的一个代码队列中，但并不会立即执行！<BR><BR>

            <span class="red">注意：</span><br>
            setInterval并不会按照指定的时间执行，JavaScript是单线程，一个任务没完成前始终挂起，<BR>
            意思是setInterval里面有一个任务需要很长时间，那么必须等它执行完才会周期调用setInterval！<BR>
            <pre class="brush:javascript">
                setInterval( function() {
                    fn( ); // 耗时超过100ms
                }, 100 );

                // 会推迟执行setInterval，当在270ms执行完，会在300ms继续调用setInterval
                // 这里只间隔30ms！所以并不能保证按照预期的周期来执行
                // 如果想保证执行周期怎么解决？
                // setTimeout，不管你操作多久，什么时候谈框确定，都会在线程完后，指定时间触发
            </pre>
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">12、</span>
        <div class="ct">
            <h2>JavaScript兼容性</h2>
            变态的时刻，ie为奇葩<BR>
            1、getAttribute; ie可以常规属性的方法来获取<BR>
            2、input.type; ie只读<BR>
            3、window.event（事件）<BR>
            4、event.x; ie下有，火狐没有<BR>
            5、event.srcElement<BR>
            6、document.getElementsByClassName<BR>
            7、document.querySelector<BR>
            。。。
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">13、</span>
        <div class="ct">
            <h2>元素查找怎么优化</h2>
            1、用id选择器，确定范围，缓存结果。再此内容区再查找需要的元素。<BR>
            2、冒泡形式查找，寻找匹配的父级元素。
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">14、</span>
        <div class="ct">
            <h2>json是什么</h2>
            数据交换格式，基于ECMAScript的一个子集，键值对方式存在。
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">15、</span>
        <div class="ct">
            <h2>怎么给String扩展方法</h2>
            给内置对象扩展方法，需从原型上添加
            <pre class="brush:javascript">
                if ( !String.prototype.getStr ) {
                    String.prototype.getStr = function( num ) {
                        return this[ num || 0 ];
                        //你想做的事情
                    };
                }
            </pre>
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">16、</span>
        <div class="ct">
            <h2>valueOf和toString有什么区别</h2>
            valueOf：返回该对象类型的原始值。<BR>
            toString: 将该对象的原始值以字符串形式返回。<BR>

            这两个方法一般是交由JS去隐式调用，以满足不同的运算情况。<BR>
            在数值运算里，会优先调用valueOf()。
            <pre class="brush:javascript">
                +"1"+2; //3
            </pre>
            在字符串运算里，会优先调用toString()。
            <pre class="brush:javascript">
                "1"+2; //12
            </pre>
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">17、</span>
        <div class="ct">
            <h2>html5新增哪些api</h2>
            video、audio、canvas、webgl、localstorage、sessonstorage、websql、
            indexedDB、websocket、Application Cache、worker、Geolocation API...
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">18、</span>
        <div class="ct">
            <h2>Web Sql Database,IndexedDB有何优点缺点</h2>
            都可做本地数据存储。<BR>
            Web Sql Database：已经不在更新，火狐不兼容。实际上并不包含在HTML5规范之中。
            它是一个独立的规范（不建议使用：代码更加复杂匿名内部类的内部函数，回调函数）。<BR><BR>
            IndexedDB：轻量级NOSQL数据库，存在兼容性，将会代替web sql database
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">19、</span>
        <div class="ct">
            <h2>离线存储优缺点,怎么更新</h2>
            1、可离线访问应用。<BR>
            2、可访问本地的缓存文件，速度更快。<BR>
            3、仅仅加载被修改过的资源，降低了服务器的访问压力。<BR><BR>
            离线存储 <= ie9 不支持<BR>
            最大支持5M<BR><BR>

            首次更新manifest时，因为页面加载已经开始或者已经完成，缓存还没来得及更新，浏览器仍使用过期的资源。<BR>
            当Application cache有更新时候，第二次才会触发。这个时候需要监听updata事件。<BR>
            首页不做离线缓存。
            <pre class="brush:javascript">
                window.applicationCache.addEventListener( "updateready", function() {
                    window.location.reload();
                });
            </pre>

            <span class="red">注意：</span><br>
            更新执行过程：是否引用manifest、检测是否更新、manifest下载完成是否更新、触发下载事件、下载文件进度、是否有旧数据、更新缓存updateready事件。
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">20、</span>
        <div class="ct">
            <h2>判断当前脚本运行在浏览器还是node环境中</h2>
            通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中。
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">21、</span>
        <div class="ct">
            <h2>script标签放在底部的body封闭之前和封闭之后有什么区别,浏览器会如何解析它们</h2>
            放在之前符合html标准包括html5标准，写在之后就是不符合标准。<BR>
            放在之前之后都回解析。没有区别，写在之前之后最终还是在dom树里，script元素还是回成为body的子节点，会等dom文档加载完请求script标签<BR>
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">22、</span>
        <div class="ct">
            <h2>检测浏览器版本有哪些方式</h2>
            判断navigator.userAgent<BR>代码网上一搜很多
        </div>
    </div>

</div>

<!-- 深入理解 -->
<div class="title"><a href="answer.html" target="_blank">深入理解</a></div>
<div class="answer">
    <div class="list">
        <span class="num" title="点击折叠">1、</span>
        <div class="ct">
            <h2>作用域执行情况</h2>
            两个概念：<BR>
            1、执行环境，也称执行上下文<BR>
            上面我们说到执行环境三种：全局、自定义函数、eval函数。<BR>
            函数调用时候回进入该函数对应的执行环境，如果又调用，那么再会创建一个新的执行环境，并且函数调用执行都存在此环境中！<BR><BR>

            2、作用域，作用域链<BR>
            作用域链就是一个上下文所有的变量对象
            <pre class='brush: javascript'>
                var x = 10;
                var fn = function() {
                    //var y->undefined
                    var y = 20;
                    console.log( x + y );   //30
                }
                fn();

                // 执行情况
                // fn里面var会声明前提，就是函数预解析，在代码执行时候会解析出变量和函数的定义
                // 函数分为创建和激活阶段（调用时）
                // 函数作用域链在函数创建时就创建，包含活动对象ao和这个函数内部或父级的变量对象vo
                // 变量x并未在fn定义，不会存在fn的ao中（他能访问所以父变量对象层级链（vo）x=10）
                // 变量y在fn定义（就是fn上下文活动对象ao），所以fn活动对象ao包含属性: y->undefined

                // 根据上面意思，活动对象是作用域的第一个对象，被添加到顶端
                // 在fn激活时（进入上下文），活动对象是：x->10,y->20
            </pre>
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">2、</span>
        <div class="ct">
            <h2>闭包是什么</h2>
            闭包是代码块和创建该代码块的上下文中数据的结合，闭包会引用上下文数据，从而提高运算效率，同时增加内存占有率
            <pre class='brush: javascript'>
                var a = 10;
                var fn = function() {
                    console.log( a );
                };
                ( function() {
                    var a = 20;
                    fn();
                    //由于上面作用域的情况，创建函数就决定作用域链
                    //闭包创建的同时，上下文的数据就会保存起来
                } )();
            </pre>
            <span class="red">注意：</span><br>
            函数都是闭包，因为它们都是在创建的时候就保存了上下文的作用域链<BR>
            即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回，因为保存了上下文数据）
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">3、</span>
        <div class="ct">
            <h2>哪些操作会内存泄漏,怎么解决</h2>
            内存泄露：指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束<BR>
            怎样让它回收：就是程序中没有变量引用某个对象，就回触发垃圾回收机制（从内存释放变量）！<BR>
            内存泄露现在在单页面中比较严重，页面得不到释放，但是某些情况下刷新后还是没办法<BR><BR>

            1、闭包引用
            <pre class='brush: javascript'>
                var outer = function() {
                    var obj = {};
                    var inner = function() {
                        //这里引用了obj对象
                    };
                    obj.inner = inner;
                };
                //创建了obj、inner变量对象，这和作用域链有关，互相引用，闭包很容易循环引用
            </pre>

            2、dom引用：当dom元素或一个ActiveX对象与普通JavaScript对象之间存在循环引用时
            <pre class='brush: javascript'>
                var elem = document.getElementById( 'id' );
                elem.onclick = function() {
                    // elem引用了click回调事件，这就是为什么事件不能直接挂载在dom元素上的原因
                };

                //解决方法
                var bindFn = function() {
                    return function() {
                        console.log( "html" );
                    };
                };
                ( function() {
                    var elem = document.getElementById( 'kk' );
                    elem.onclick = bindFn();
                    return elem;
                } )();
            </pre>

            3、隐式转换类型ie下
            <pre class="brush:javascript">
                var str = "hello js";
                console.log( str.length );
                //这个是因为string本来没有length属性，在底层js引擎自动创建临时的string对象
                //解决方案：
                console.log( new String( str ).length );
            </pre>
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">4、</span>
        <div class="ct">
            <h2>this指向</h2>
            this指向：可能是全局、构造函数、eval<BR>
            this是执行上下文的一个属性（变量对象vo），this在进入上下文时确定，并且在上下文运行期间永久不变。<BR>
            this调用函数的方式来决定。<BR><BR>
            1、全局
            <pre class='brush: javascript'>
                console.log( this );        //window
                var fn = function() {
                    console.log( this );    //window
                };
                fn();
            </pre>

            2、构造函数
            <pre class='brush: javascript'>
                var Fn = function() {
                    console.log( this );    //Fn
                    // this指向了new创建了的对象，这里的this可以理解成Fn的一个副本（vo引用了实例）
                };
                new Fn();
            </pre>

            3、对象方法调用
            <pre class='brush: javascript'>
                var obj = {
                    fn: function() {
                        console.log( this );    //obj
                    };
                }
                obj.fn();
            </pre>

            4、apply、call可以改变this指向
            <pre class='brush: javascript'>
                var obj = {};
                var fn = function() {
                    console.log( this );    //obj对象
                };
                fn.call( obj );
            </pre>
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">5、</span>
        <div class="ct">
            <h2>new,原型,原型链都做了什么</h2>
            new：<BR>
            1、创建一个空对象，并且this（变量对象vo）引用该对象，同时还继承了该函数的原型。<BR>
            2、属性和方法被加入到this引用的对象中。<BR>
            3、新创建的对象由this所引用，并且最后隐式的返回this。<BR><BR>

            原型：每个对象内部属性，自动创建的隐藏属性<BR>
            原型链：每个对象内部属性的属性<BR>

            <pre class='brush: javascript'>
                var Fn = function( a ) {
                    this.a = a;
                };
                Fn.prototype.a = 2;
                Fn.prototype.constructor = Fn;
                var fn = new Fn( 1 );

                console.log( fn.a === 1 );                                                  //true
                console.log( fn.constructor === Fn );                                       //true
                console.log( Fn.constructor === Function );                                 //true
                console.log( Fn.prototype.constructor === Fn );                             //true
                console.log( Fn.prototype.constructor.constructor === Function );           //true
                //fn是Fn的实例
                //Fn的constructor为什么是Funciton，因为Fn是构造函数，向上查找原型链，直到顶级Function
            </pre>
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">6、</span>
        <div class="ct">
            <h2>继承实现方式</h2>
            对象冒充，apply、call，prototype，拷贝继承，创建空对象，Object.create
            <pre class='brush: javascript'>
                function Parent( age ) {
                    this.name = "coco";
                    this.age = age;
                }
                Parent.prototype.run = function() {
                    return this.name  + ' || ' + this.age;
                };
                function Child( age ){
                    Parent.call( this, age );       //对象冒充，给超类型传参
                }
                Child.prototype = new Parent();     //原型链继承
                var test = new Child( 20 );
                alert( test.run() );
                //复制粘贴一瞬间
            </pre>

            <pre class="brush:javascript">
                var extend = function( Child, Parent ) {
                    var F = function(){};
                    F.prototype = Parent.prototype;
                    Child.prototype = new F();
                    Child.prototype.constructor = Child;
                    Child.uber = Parent.prototype;
                };

                var Animal = function() {};
                var Cat = function() {};
                Animal.prototype.species = "动物";

                extend( Cat, Animal );
                var cat1 = new Cat();
                alert( cat1.species ); // 动物

            </pre>
        </div>
    </div>

    <div class="list">
        <span class="num" title="点击折叠">7、</span>
        <div class="ct">
            <h2>call,apply</h2>
            用另一个对象替换当前对象，可改变函数的对象执行上下文。<BR>
            call：
            <pre class='brush: javascript'>
                var obj = {
                    num: 1
                };
                var fn = function( num ) {
                    console.log( typeof num )
                    console.log( this.num , num );
                };
                fn.call( obj, 2 );                  //1,2
                fn.apply( obj, [ 20, 30 ] );        //1,20
            </pre>
        </div>
    </div>
</div>
<div style="height:100px" id="kk"></div>
<script>
    $(document).ready(function(){
        SyntaxHighlighter.all();
        $( "body" ).on( "click", ".num", function( e ) {
            $( this).next().toggle();
        });
        $( "body" ).on( "click", ".title", function( e ) {
            e.preventDefault();
            $( this).next().toggle();
        });
    });

</script>
</body>
</html>



